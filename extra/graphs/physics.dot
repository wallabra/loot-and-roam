// ------------------------------------------------------------------------------------------
// This graph demonstrates the structure of the physics simulation and events in Loot & Roam.
// ------------------------------------------------------------------------------------------
//
// (c) 2025 GameCircular.
// Written by:
// * Gustavo Ramos Rehermann (rehermann6046@gmail.com)
//
// For license details, please see the bottom of the file.

digraph Physics {
    label="Physics Architecture and Events"
    labelloc = "t"
    layout=neato
    overlap=prism
    esep="+10"
    node [shape=record]

    // "Registries" are Bevy resources which keep track of data that's used by other objects.
    //
    // When an object is removed, its associated registry elements have to all be deleted too.
    // (This is faciliated by the ObjectRegistry.)

    subgraph Outer {
        BevyResources [label="Bevy Resources" shape=trapezium height=1.5 width=2]
        BevyResources -> { PhysicsPrimitiveRegistry, ObjectRegistry, EnvironmentRegistry, TerrainNode }

        BevyComponents [label="Bevy Components" shape=trapezium height=1.5 width=2]
        BevyComponents -> {
            PhysicsComponent,
            RenderComponent
        }
        RenderComponent -> RenderNode -> { OtherRenderNodes, AnchoredRenderNode }
        OtherRenderNodes [label="..." shape=plain]
        PhysicsComponent -> ObjectRegistry [style=dotted, color=gray]
        AnchoredRenderNode -> PointRegistry [style=dotted, color=gray]
    }

    subgraph PhysicsArchitecture {
        //----
        // PRIMITIVES.
        
        // PhysicsRegistry is composed of multiple sub-registries.
        PhysicsPrimitiveRegistry -> {
            PointRegistry,  # points with mass and inertia
            SpringRegistry, # springs between points (radial constraints)
            HingeRegistry,  # hinges between points (angular constraints)
            VolumeRegistry  # volumes anchored on points
        }
        
        PointRegistry
        SpringRegistry

        pos [shape=plain]
        vel [shape=plain]
        mass [shape=plain]
        stiffness [shape=plain]
        target_dist [shape=plain]
        min_angle [shape=plain]
        max_angle [shape=plain]

        PointRegistry -> Point -> { pos, vel, mass }
        SpringRegistry -> Spring -> { stiffness, target_dist }
        HingeRegistry -> Hinge -> { min_angle, max_angle }
        VolumeRegistry -> Volume

        { Spring, Hinge, Volume } -> Point [style=dotted, color=gray]
        Volume -> VolumePrimitive

        VolumePrimitive [color=brown]
        {
            node[shape=plain];
            Cylinder
            Sphere
        }
        VolumePrimitive -> {
            Cylinder,
            Sphere
        } [color="brown" style=dotted] // enum

        // The object registry tracks grouped allocations of primitives in the other registries.
        ObjectRegistry -> PhysicsObjectRegistry -> PhysicsObjectReference
        PhysicsObjectReference -> {
            PointRegistry,
            SpringRegistry,
            HingeRegistry,
            VolumeRegistry
        } [style=dotted, color=gray]

        //----
        // ENVIRONMENT.

        // The environment is similarly broken down into generally self-contained components.
        EnvironmentRegistry -> {TerrainNode, WindMachine}

        WindMachine // To be implemented: anything that can update its own wind direction semi-regularly.

        // The terrain is not only generated procedurally, but also evaluated dynamically
        // as a tree of nodes, and cached on a per-chunk basis.
        TerrainNode -> {
            TerrainPrimitiveNode,
            TerrainJoinNode,
            TerrainTransformNode
        }
        TerrainPrimitiveNode -> {
            ConstantNode,
            ParabolaNode,
            NoiseNode
        }
        TerrainJoinNode -> {
            HardmaxNode,
            SmoothmaxNode,
            AddNode,
            MultiplyNode
        }
        TerrainTransformNode -> {
            ScaleNode
        }

        TerrainGenerator -> TerrainNode [color=red]

        TerrainNode -> {      // (note that the below fields operate on different dimensions!)
            TerrainSdf3D,     // Vec3 -> f64
            TerrainHeightmap  // Vec2 -> u16
        } [color=red]

        TerrainSdf3D -> TerrainSdf2D [color=blue] // can convert to
    }

    // Bevy entity systems cannot affect the physics system directly.
    // 
    // Instead, it must produce PhysicsEvents which are passed to the system, and
   // consumed accordingly.
    subgraph PhysicsEvents {
        SinglePointForce [shape=ellipse]
        RadialForce [shape=ellipse]
        PhysicsObjectDestroy [shape=ellipse]
        PhysicsObjectCreate [shape=ellipse]
        Tick [shape=ellipse]
        
        PointForce -> PointRegistry [color=green]
        RadialForce -> PointRegistry [color=green]

        { PointForce, RadialForce } -> ForceTypeDispatch
        ForceTypeDispatch [xlabel=enum color=brown]
        Instant [shape=plain]
        TimeScaled [shape=plain]
        ForceTypeDispatch -> { Instant, TimeScaled } [color=brown, style=dotted]
        
        PhysicsObjectDestroy -> ObjectRegistry [color=green]
        PhysicsObjectCreate -> PhysicsPrimitiveRegistry [color=green]
        Tick -> PhysicsPrimitiveRegistry [color=green]
        PhysicsObjectCreate -> PhysicsObjectReference [color="blue:invis:blue"]

        PhysicsEvent -> {
            SinglePointForce,
            RadialForce,
            PhysicsObjectDestroy,
            PhysicsObjectCreate,
            PointForce,
            Tick
        }
    }

}


// (c)2025 GameCircular.
// All Loot & Roam documentation and support material is marked with CC0 1.0 Universal: https://creativecommons.org/publicdomain/zero/1.0/
